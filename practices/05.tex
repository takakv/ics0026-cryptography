\documentclass{practice}

\title{5}
\date{\today}

%\usepackage{etoolbox}
%\makeatletter
%\preto{\@verbatim}{\topsep=0pt \partopsep=-2\parsep }
%\makeatother

\usepackage{crysymb}

\usepackage{fancyvrb}
\fvset{listparameters=\setlength{\topsep}{0pt}\setlength{\partopsep}{0pt}}

\usepackage{listings}

\lstset{
basicstyle=\small\ttfamily,
columns=flexible,
breaklines=true
}

\begin{document}
\maketitle

\begin{task}{OpenSSL}
  \textit{Preface.}
  During last week's practice we learnt about the following three OpenSSL tools:
  \begin{itemize}
    \item \href{https://docs.openssl.org/master/man1/openssl-genpkey/}{\texttt{genpkey}}: utility for generating a private key (RSA, EC) or parameters (DH, DSA, EC)
    \item \href{https://docs.openssl.org/master/man1/openssl-pkey/}{\texttt{pkey}}: utility for processing keys, e.g. change their format (PEM, DER) or passphrase
    \item \href{https://docs.openssl.org/master/man1/openssl-pkeyutl/}{\texttt{pkeyutl}}: utility for actual operations with keys (e.g. encryption or signing)
  \end{itemize}

  To generate parameters instead of a private key with the \texttt{genpkey} utility, you must use the \texttt{-genparam} option.
  For example, if you one day feel the strong urge to generate a large prime before going to bed, you can use the following command:
  \begin{Verbatim}
openssl genpkey -genparam -algorithm dh \
    -pkeyopt dh_paramgen_prime_len:3072
  \end{Verbatim}

  If you wonder what the dots, plus signs, and asterisks that appear mean, then for DH there is a nice InfoSec Stack Exchange \href{https://security.stackexchange.com/a/140639}{\textit{post}} on it.

  In practice, perhaps the primary use case for generating parameters in this manner with OpenSSL is to publish the parameters or share them with other entities.
  These parameters then form the basis of subsequent procedures.
  For example, to generate a private key with OpenSSL based on a set of parameters, you can use the \texttt{-paramfile} option.

  \textit{Task.}
  For this task, familiarise yourself with the OpenSSL documentation.
  Then, generate a password-protected $3072$-bit RSA key encrypted with AES-128 in CBC mode.
\end{task}

\begin{task}{Investigating the EC key}
  \textit{Preface.}
  In class, I briefly mentioned that elliptic curve cryptography is not typically used for encryption, rather it is popular for signing and key agreement.
  One reason for this is that to perform encryption directly with an EC-system, you somehow need to represent your plaintext on a curve.

  If you think about RSA, this was fairly straightforward: you need the integer representation of your data bytes to be smaller than the modulus, meaning that the whole range $\{0, 1, \dots, n - 1\}$ is usable (for naive RSA).
  For elliptic curves, this does not hold, and you need more complex mapping schemes to achieve this.
  Therefore, if you hear encryption in an EC context, it's often based on ECDH or ECIES\footnote{\url{https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme}} instead of being \enquote{direct} encryption such as EC ElGamal. 

  While we will make heavier use of EC once we have learnt about digital signatures, let us for now investigate how EC can power key agreements.
  In Python, we can generate public keys using the \href{https://pycryptodome.readthedocs.io/en/latest/src/public_key/ecc.html}{\texttt{ECC}} module of the \href{https://pycryptodome.readthedocs.io/en/latest/src/public_key/public_key.html}{\texttt{Crypto.PublicKey}} package.

  \textit{Task.}
  For this task, read through the PyCryptodome documentation and then generate a P-384 key that is \emph{not} protected by a password.
  Next, export the key and investigate what makes up this key by dumping the ASN.1 structure.

  Generate now a P-384 key with explicit arguments with OpenSSL (read the documentation!).
  Dump the ASN.1 structure of this key.
  How does it compare to what was generated by PyCryptodome?

  Finally, try to get PyCryptodome and OpenSSL to output the same private key structure.

  \textit{Note.}
  In class, I said that Curve25519 is a solid default choice.
  The reason I have chosen P-384 here instead is that there is no convenient way to get an explicit Curve25519 key with tools we have learnt so far.

  \begin{tcolorbox}[title=Warning]
    Password protecting keyfiles is good practice (e.g. SSH or PGP keys) and you should generally do so in a real world setting.
    If your secret key is leaked and it is not password protected, anyone can use it to perform secret key operations.
    \tcblower
    Exceptions of course apply, but then you need to know what you are doing.
    Justifications similar to \enquote{but who would attack me} (as many of you have for FDE) are not reason enough.
    Build a habit!
  \end{tcolorbox}
\end{task}

\begin{task}{DH and symmetric ciphers}
  \textit{Preface.}
  For this task, we will implement a makeshift hybrid encryption scheme instead of using ECIES.
  Recall that while this is fine for learning purposes, you should not use this in a production setting.

  In class I raised the question of how should we use a key generated with DH, e.g. for encryption.
  The answer was to use a \emph{cryptographic key derivation function} (KDF), something we also briefly covered when talking about symmetric encryption schemes (e.g. FDE, password managers).
  Non-cryptographic KDFs exist similarly to non-cryptographic PRNGs.
  Not using a suitable KDF can break the security of the scheme!

  We will cover cryptographic and password-based KDFs in more detail next week when we talk about hash functions, but you should already have an idea of their general purpose.
  The general rule also applies: you must not use just any function that you think satisfies some properties.
  There are algorithms specifically designed and approved for such tasks.

  I also introduced the concept of \emph{perfect forward secrecy} (PFS) which involved generating ephemeral keys used for communication sessions that must be discarded after the session.
  That way, if the server's long-term key is compromised, the confidentiality of pre-breach communications remains intact.

  PyCryptodome provides functionality to derive keys with ECDH through the \href{https://pycryptodome.readthedocs.io/en/latest/src/protocol/dh.html}{\texttt{DH}} module of the \href{https://pycryptodome.readthedocs.io/en/latest/src/protocol/protocol.html}{\texttt{Crypto.Protocol}} package.
  The library requires you to know the other party's long term or/and ephemeral public key and to provide your own long term or/and ephemeral secret.

  \textit{Task.}
  For this task do the following:
  \begin{enumerate}
    \item Acquire the server's (Discord bot's) long-term P-384 EC public key.
    \item Generate your own long-term P-384 public and ephemeral key.
    \item Derive the shared secret with \href{https://pycryptodome.readthedocs.io/en/latest/src/hash/shake128.html#shake128}{\texttt{SHAKE128}} as the KDF to generate a \enquote{partial} ephemeral session key.
    
    Note that I call the session key partial here.
    Good practice is that both the server and the client contribute to the ephemeral session key.
    In this case, only you contribute an ephemeral component while the server only provides a static key.
    The reason for that is to make calling the Discord bot simpler.

    Some more info on static-ephemeral DH \href{https://crypto.stackexchange.com/a/61760}{\emph{here}}.

    \item Encrypt a message with AES-128-CBC and send it to the server for decryption.
  \end{enumerate}

  \textit{Note.}
  There are two reasons I chose SHAKE here:
  \begin{itemize}
    \item given as an example in the documentation so it is easier for you,
    \item SHAKE has extendable output, meaning that you can choose the desired output length (as opposed to most hash functions).
  \end{itemize}
\end{task}

\begin{task}{ElGamal}
  \textit{Preface.}
  In class we saw that ElGamal is \emph{partially homomorphic} with respect to multiplication, often simply called \enquote{multiplicatively homomorphic}.
  That is, if you multiply two ciphertexts $c_1$, $c_2$ and decrypt the resulting ciphertext, you will get $m_1 \cdot m_2$.
  More mathematically,
  \begin{align*}
    \DEC_\SK(c_1 \cdot c_2) &= 
    \DEC_\SK\bigl(\ENC_\PK(m_1) \cdot \ENC_\PK(m_2)\bigr)\\
    &= \DEC_\SK\bigl(\ENC_\PK(m_1\cdot m_2)\bigr)\\
    &= m_1 \cdot m_2
  \end{align*}
  holds for classic ElGamal.

  \textit{Task.}
  For this task, generate a $3072$-bit ElGamal key and encrypt two different integers.
  Multiply the ciphertexts and decrypt the result.
  Is the result the product of the two integers?

  Then, repeat three times: \enquote{my implementation is insecure and I will not use it for actual encryption}.
\end{task}
\end{document}
