\documentclass{practice}

\title{5}
\date{\today}

%\usepackage{etoolbox}
%\makeatletter
%\preto{\@verbatim}{\topsep=0pt \partopsep=-2\parsep }
%\makeatother

\usepackage{crysymb}

\usepackage{fancyvrb}
\fvset{listparameters=\setlength{\topsep}{0pt}\setlength{\partopsep}{0pt}}

\usepackage{listings}

\lstset{
basicstyle=\small\ttfamily,
columns=flexible,
breaklines=true
}

\begin{document}
\maketitle

\begin{task}{A more generic OpenSSL}
  \textit{Preface.}
  In last week's practice I introduced the following three OpenSSL tools:
  There are three primary OpenSSL tools for working with RSA:
  \begin{itemize}
    \item \href{https://www.openssl.org/docs/man3.0/man1/openssl-genrsa.html}{\texttt{genrsa}}: utility for generating an RSA private key
    \item \href{https://www.openssl.org/docs/man3.0/man1/openssl-rsa.html}{\texttt{rsa}}: utility for `processing' RSA keys
    \item \href{https://www.openssl.org/docs/man3.0/man1/openssl-rsautl.html}{\texttt{rsautl}}: utility for encrypting, decrypting, signing, and verifying signatures
  \end{itemize}

  In reality, you should not longer use these utilities.
  When using \texttt{rsault} with OpenSSL version 3.0 and later you will get a deprecation warning.
  This warning is not there yet for \texttt{genrsa} and \texttt{rsa} as of version 3.2, nevertheless you should favour the new general utilities instead.

  More generally, OpenSSL provides the following three tools for working with public keys:
  \begin{itemize}
    \item \href{https://www.openssl.org/docs/man3.0/man1/openssl-genpkey.html}{\texttt{genpkey}}: utility for generating a private key (RSA, EC) or parameters (DH, DSA, EC)
    \item \href{https://www.openssl.org/docs/man3.0/man1/openssl-pkey.html}{\texttt{pkey}}: utility for processing keys
    \item \href{https://www.openssl.org/docs/man3.0/man1/openssl-pkeyutl.html}{\texttt{pkeyutl}}: utility for actual operations with keys
  \end{itemize}

  To generate parameters instead of a private key with the \texttt{genpkey} utility, you must use the \texttt{-genparam} option.
  For example, if you one day feel the strong urge to generate a large prime before going to bed, you can use the following command:
  \begin{Verbatim}
openssl genpkey -genparam -algorithm dh \
    -pkeyopt dh_paramgen_prime_len:3072
  \end{Verbatim}

  If you wonder what the dots, plus signs, and asterisks that appear mean, then for DH there is a nice InfoSec Stack Exchange \href{https://security.stackexchange.com/a/140639}{\textit{post}} on it.

  In practice, perhaps the primary use case for generating parameters in this manner with OpenSSL is to publish the parameters or share them with other entities.
  These parameters then form the basis of subsequent procedures.
  For example, to generate a private key with OpenSSL based on a set of parameters, you can use the \texttt{-paramfile} option.

  \textit{Task.}
  For this task, familiarise yourself with the OpenSSL documentation.
  Then, generate a password-protected $3072$-bit RSA key encrypted with AES-128 in CBC mode.
\end{task}

\begin{task}{Investigating the EC key}
  \textit{Preface.}
  In class, I briefly mentioned that elliptic curve cryptography is not typically used for encryption, rather it is popular for signing and key agreement.
  One reason for this is that to perform encryption directly with an EC-system, you somehow need to represent your plaintext on a curve.

  If you think about RSA, this was fairly straightforward: you need the integer representation of your data bytes to be smaller then the modulus, meaning that the whole range $\{0, 1, \dots, n - 1\}$ is usable (for naive RSA).
  For elliptic curves, this does not hold, and you need more complex mapping schemes to achieve this.
  Therefore, if you hear encryption in an EC context, it's often based on ECDH or ECIES\footnote{\url{https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme}} instead of being `direct' encryption such as EC ElGamal. 

  While we will make heavier use of EC once we have learnt about digital signatures, let us for now investigate how EC can power key agreements.
  In Python, we can generate public keys using the \href{https://pycryptodome.readthedocs.io/en/latest/src/public_key/ecc.html}{\texttt{ECC}} module of the \href{https://pycryptodome.readthedocs.io/en/latest/src/public_key/public_key.html}{\texttt{Crypto.PublicKey}} package.

  \textit{Task.}
  For this task, read through the PyCryptodome documentation and then generate a P-384 key that is \emph{not} protected by a password.
  Next, export the key and investigate what makes up this key by dumping the ASN.1 structure.

  Generate now the a P-384 key with explicit arguments with OpenSSL (read the documentation!).
  Dump the ASN.1 structure of this key.
  How does it compare to what was generated by PyCryptodome?

  \textit{Note.}
  In class, I said that Curve25519 is a solid default choice.
  The reason I have chosen P-384 here instead is that there is no convenient way to get an explicit Curve25519 key with tools we have learnt so far.

  \begin{tcolorbox}[title=Warning]
    Password protecting keyfiles is good practice (e.g. SSH or PGP keys) and you should generally do so in a real world setting.
    If your secret key is leaked and it is not password protected, anyone can use it to perform secret key operations.
    \tcblower
    Exceptions of course apply, but then you need to know what you are doing.
    Justifications similar to `but who would attack me' (as many of you have for FDE) are not reason enough.
    Build a habit!
  \end{tcolorbox}
\end{task}

\begin{task}{DH and symmetric ciphers}
  \textit{Preface.}
  Hopefully by now you have engraved into your brain the mantra `do not implement your own crypto'.
  This means that not only should you not implement your own algorithms, you also should not implement/compose your own protocols.
  Still, since we have not yet reached the TLS week, we need to break rules a bit for learning purposes if we want to experiment with DH.

  In class I raised the question of how should we use a key generated with DH, e.g. for encryption.
  The answer was to use a \emph{cryptographic key derivation function} (KDF), something we also briefly covered when talking about symmetric encryption schemes (e.g. FDE, password managers).
  Non-cryptographic KDFs exist similarly to non-cryptographic PRNGs.
  Not using a suitable KDF can break the security of the scheme!

  We will cover cryptographic and password-based KDFs in more detail next week when we talk about hash functions, but you should already have an idea of their general purpose.
  The general rule also applies: you must not use just any function that you think satisfies some properties.
  There are algorithms specifically designed and approved for such tasks.

  PyCryptodome provides functionality to generate keys with ECDH through the \href{https://pycryptodome.readthedocs.io/en/latest/src/protocol/dh.html}{\texttt{DH}} module of the \href{https://pycryptodome.readthedocs.io/en/latest/src/protocol/protocol.html}{\texttt{Crypto.Protocol}} package.

  \textit{Task.}
  For this task, implement a makeshift protocol which uses ECDH with \href{https://pycryptodome.readthedocs.io/en/latest/src/hash/shake128.html#shake128}{\texttt{SHAKE128}} as the KDF to generate a key, and then use this key for AES-128-CBC encryption and decryption.

  There are two reasons I chose SHAKE here:
  \begin{itemize}
    \item given as an example in the documentation so it is easier for you
    \item SHAKE has extendable output, meaning that you can choose the desired output length (as opposed to most hash functions)
  \end{itemize}
\end{task}

\begin{task}{ElGamal}
  \textit{Preface.}
  In class we saw that ElGamal is \emph{partially homomorphic} with respect to multiplication, often simply called `multiplicatively homomorphic'.
  That is, if you multiply two ciphertexts $c_1$, $c_2$ and decrypt the resulting ciphertext, you will get $m_1 \cdot m_2$.
  More mathematically,
  \begin{align*}
    \DEC_\SK(c_1 \cdot c_2) &= 
    \DEC_\SK\bigl(\ENC_\PK(m_1) \cdot \ENC_\PK(m_2)\bigr)\\
    &= \DEC_\SK\bigl(\ENC_\PK(m_1\cdot m_2)\bigr)\\
    &= m_1 \cdot m_2
  \end{align*}
  holds for classic ElGamal.

  PyCryptodome does offer an \href{https://pycryptodome.readthedocs.io/en/latest/src/public_key/elgamal.html}{\texttt{ElGamal}} implementation although it lists it as `obsolete'.
  While their warning does hold in the general case, there are contexts where ElGamal can offer properties that RSA cannot (e.g. e-voting).

  \textit{Task.}
  For this task, generate a $3072$-bit ElGamal key and encrypt two different integers.
  Multiply the ciphertexts and decrypt the result.
  Is the result the product of the two integers?

  If you are feeling spicy, try repurposing the library ElGamal to do \emph{lifted} ElGamal, i.e. with encryption in the exponent (encrypt $g^m$ instead of $m$).
  Are you able to recover the message?
  Do you get an additive property instead?
\end{task}
\end{document}
